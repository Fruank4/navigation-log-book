骨架实现类

通过对接口实现一个抽象的骨架实现，可以把接口和抽象类的优点结合起来。其中，接口负责定义类型，也可以提供一些缺省的方法，而骨架实现类则负责实现除了接口方法之外的实用方法。

骨架实现类被称为AbstractInterface，这里的Interface是其实现的接口的名字。例如Collections Framework为每个重要的集合接口都实现了一个骨架实现，包括AbstractCollection、AbstractSet、AbstractList、AbstractMap

进一步地，在抽象类的基础上进一步扩展，我们定义具体的实现类。以这种方式定义的实现类中，我们不仅可以对接口的核心功能做出实现，还可以受益于其继承的抽象骨架中的方法，以及重复使用接口中的缺省方法。



骨架实现类是为了继承的目的而设计的，因此对其验证最好的方式就是：写几个子类去继承它。并且，这种接口-骨架-子类的复杂继承结构需要有明确的好的文档告诉后人：你在这些环节都做了些什么。

这有助于他们能很好地继续利用这种层次结构，并延续下去。



缺省方法

尽量避免利用缺省方法在现有的接口上添加新的方法，除非有特殊需要，但在这么做之前一定要周密谨慎地考虑：缺省的方法实现是否会破坏现有接口以及其实现类的功能和规范。

一个典型的例子就是 Apache.commons包中的同步集合，它使用了包装转发模式

然而，在创建新的接口的时候，用缺省方法提供标准的实现的确是很方便的，它简化了实现接口的任务。



接口只用于定义类型

接口中定义的字段默认都是 常量，在接口中随意引入常量是不明智的，除非你已明确该常量和该接口有着紧密的联系。

​	纯粹的常量接口则更是一种严重错误的方式，

- 在类的内部使用常量，属于是实现细节，将这些细节暴露出去毫无用处，并且让人困惑。

- 如果非final类实现了常量接口，这会导致该实现类的子类都受到了这些值的污染。

