只使用与类名相同的构造方法是不好的：

- 大量同名的方法，让人感到困惑
- 总是创建新的对象，并且只能返回本身的类对象，不能根据条件不同灵活地返回对象
- 不能明确表达含义

因此我们在由其他参数或对象生成对象实例时，更推荐使用不同名称的静态工厂方法

- from——类型转换方法，只有单个参数，常见如 Date.from(instant)
- of——聚合方法，带有多个参数，意思是把他们聚合起来。
- getInstance——获取实例方法，通常不带参数，返回类中本来就有的静态对象
- newInstance——获取实例，通常不带参数，但是通常会在方法中新建一个对象



带有非常多参数的（构造）方法是不好的：

- 可以使用无参构造方法，然后用setter方法给它的每个字段进行赋值，这种方式很通用。

- 也可以使用作为静态内部类的builder来构造对象，并在builder的方法中完成参数有效性的检查。

  - 支持泛型：外层类用泛型，builder也可以用泛型

  - 支持层级：外层类继承了，builder也需要继承外层类的builder



带有非常多参数的接口方法是不好的：

应该单独定义个类，用于承载这些参数（必选或非必选），便于调用时能够清楚理解，也便于扩展。

- options——行为选项
- queryParams——查询参数





不要用 Singleton和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ;也不要直接用这个类来创建这些资源 。 而应该将这些资源的实例或者资源工厂传给构造器(或者静态工厂，或者构建器)，通过它们来创建类 。 这个实践就被称作依赖注入，它极大地提升了类的灵活性 、 可重用性和可测试性 。



避免在不必要的时候创建新的对象，尤其是开销很大的对象，我们应该

- 根据场合，选择重用原有的对象或者创建一个新对象。
- 在使用的对象的时候，清楚它是重用的，还是新创建的。

eg：String、Pattern vs String.matches()、Long vs long、静态工厂 vs 构造器



“内存泄漏”，随着垃圾回收器活动的增加，或者由于内存占用的不断增加，程序的性能也会逐渐降低。 在极端的情况下，这种内存泄漏会导致磁盘交换( Disk Paging)，甚至导 致程序失败( OutOfMemoryError 错误)：

- 维护着过期对象的引用，会导致垃圾回收期无法识别出来
- 缓存中的数据没有设置过期时间，这里建议使用WeakHashMap



finalizer和cleaner存在着性能上的问题和安全上的问题，同时他们也不保证即时清理对象，甚至压根保证不了能清理对象，因此并不能依赖他们来回收资源。更出色的方法应该是让资源继承AutoCloseable接口，从而利用try-with-trasure去关闭，或者手动调用close()来关闭。如果我们忘记调用了close()，终结方法和清除方法作为安全网来兜底，这也是他们仅存的意义。同时我们还要注意不要产生循环引用

- lambda闭包 捕捉了外围对象
- 非静态内部类 包含了外层类对象的引用











在判断对象相等时我们需要调用equals方法，为了满足特定的需要则需要重写对象的equals方法，在重写时有如下几条建议：

- 重写之后满足自反性，传递性，一致性
- 先判空，再用==号，再用instance进行类型判断（而不是getClass），再进行字段比较
- 不要将equals方法的入参修改为其他的类型，那将不是重写，而是重载。这也同样适用于其他Object方法

- 重写equals时记得重写hashCode，这样在语义上才能保持一致，也这样的对象才能作为HashMap的key

  方法是result = 31 * (Type.hashCode(a) + Type.hashCode(b) +.....Type.hashCode(x)  )

既然 Cloneable 接口并没有包含任何方法，那么它到底有什么作用呢?它决定了 Object 中受保护的 clone 方法实现的行为:如果 一 个类实现了 Cloneable, Object 的 clone 方法就返回该对象的逐域拷贝，否则就会抛出 CloneNotSupportedException 异常 。



简而言之，所有实现了 Cloneable 接口的类都应该覆盖 clone 方法，并且是公有的方法，它的返回类型为类本身 。 该方法应该先调用 super.clone 方法，然后修正任何需要修正的域。但基本没人使用，太麻烦了。

对象拷贝的更好的办法是提供 一 个拷贝构造器( copy constructo「)或拷贝工厂( copy factory )。对于特别复杂的对象，也可以使用序列化的方式完成深拷贝。





每当实现一个对排序敏感的类时，都应该让这个类实现 Comparable 接 口，以便其实例可以轻松地被分类 、 搜索，以及用在基于比较的集合中 。 每当在 com­pareTo 方法的实现中比较域值时，都要避免使用 < 和>操作符（非常烦琐，并且容易出错），而应该在装箱基本类型 的类中使用静态的 compare 方法，或者在 Comparator 接口中使用比较器构造方法 。