1、枚举的可读性更好， 也更加安全，功能更加强大（遍历、对比、行为），有些许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于属性与每个常量的关联以及其行为受该属性影响的方法。枚举类自带的两个方法很重要：

- Values（）

- valueOf（）



2、枚举类中实现抽象方法，可以为每个枚举类赋予特定的行为。使用Switch的扩展性不好（新建了一个枚举类时，需要让Switch中也出现，这很容易忘记），所以我们在枚举成员类行为各不相同时，可以直接在枚举类中添加一个抽象方法，让每个枚举类做出其实现。但是如果类似是“周末”、“工作日”一样的分类话，那就需要再定义一个内置的策略枚举来承担这部分责任了。



 2、Enum的序号方法使用起来很不好控制，所以不要使用，尤其是以下两种场合

- 用EnumSet代替位域

 EnumSet 类来有效地表示从单个枚举类型中提取的多个值的多个集合 。 这个类实现 Set 接口，提供了丰富的功能、类型安全性，以及可以从任何其他 Set 实现中得到的互用 性 。 性能也不错，因为底层每个 EnumSet 内容都表示为位矢量。

- 用EnumMap代替枚举索引的数组

 EnumMap在运行速度方面之所以能与通过序数索引的数组相媲美，正是因为 EnuMap 在内部使用了这种数组 。 但是它对程序员 隐藏了这种实现细节，集 Map 的丰富功能和类型安全与数组的快速于一身 。 注意 EnumMap 构造器采用键类型的 Class 对象(有限制的类型令牌)



**在必要时，让枚举类去实现接口吧。**

 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础 枚举类型来对它进行模拟 。 这样允许客户端编写自己的枚举(或者其他类型)来实现接口 。 如 果 API 是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可





Test 注解（marker-annotation）类型的声明就是它自身通过 Retention 和 Target 注解进行了注解 。 注解类型声明中的这种注解被称作元注解( meta-annotation)。 @Retention(RetentionPolicy . RUNTIME)元注解表明 Test 注解在运行时也应该存在，否则测试工具就无法知道 Test 注 解。 @Target(ElementType.METHOD)元注解表明， Test 注解只在方法声明中才是合法的:它不能运用到类声明、域声明或者其他程序元素上 。

注解并不会改变修饰对象的语义和行为，但是却非常有效地标识了其特点，并可以对其进行特性的操作。

m.isAnnotationPresent(Test.class)

getAnnotation(Test.class)

getDeclaredAnnotation()

getDeclaredMethod()

标记接口有时候也蛮不错的，如果你发现自己 在编写的是目标为 ElementType.TYPE 的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否会更加合适 。

在Java虚拟机中，获取某一个类的所有子类需要利用反射才能做到。

但是在Spring容器中，获取某一个类的所有子类则可以利用applicationContext对象
